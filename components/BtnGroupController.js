import React, { useState, useEffect, useRef } from 'react';
import styles from '../styles/Controller.module.css';
import BtnController from './BtnController';
import SkeletonEdgeController from './SkeletonEdgeController';
import { Select, InputNumber, Button, Space } from 'antd';
import { DownOutlined, DeleteOutlined} from '@ant-design/icons';
// import {Button} from 'react-bootstrap';

const BTNNUM_MAX=50


export default function BtnGroupController(props) {
    /**
        To configure a annotating btn group.
        Produce btnGroup data: 
            {groupIndex: {
                // groupIndex:  , // even though this seems redundent, user doesn't need to handle it, so it's ok.
                groupType: 'shape',
                btnType: 'bbox',
                btnNum: 2,
                childData: [
                    {index: 0, 
                    btnType: 'bbox',
                    label: 'fly',
                    color: '#FFFFFF'
                    },
                    {index: 1, ...},
                    ...
                ]}
            }
        Props: 
            index: unique index, to indicate the order of btn groups If not provided, then set up index state.  //Required. //when specify onDelete. To distinguish from other btnGroupController
            defaultGroupType: 'category'/'shape'. Optional. When specified, the btnType dropdown will be generated accordingly; otherwise, use general list.
            defaultBtnType: 'bbox'. Optional. When specified, the default value of the btnType select will be set.
            defaultBtnNum: integer. Optional.
            maxBtnNum: integer. Optional
            //!!!!! The data and setData cannot be replaced by an internal state or ref, because there is no btn to trigger passing internal data to props
            data: object {id_1: arr_2, ...}. Required. Used with setData. To hold btn data generated by the controller
            setData: function. Required. The setter of data. Use as [data, setData]=useState()
            groupTypePlaceHolder: 'Group type'
            btnTypePlaceHolder: 'Btn type'
            disableGroupTypeSelect: boolean. False by default, true when specified. Whether to disable groupType selcet.
            disableBtnTypeSelect: boolean. False by default, true when specified. Whether to disable btnType select.
            disableBtnNumInput: boolean. False by default, true when specified. Whether to disable btn num input.
            // enableGenerateBtn: boolean. False by defualt, true when specified. Whether to include the generate btn
            enableDelete: boolean. False by default, true when specified. Whether to include the delete btn.
            onGroupTypeChange: Callback when group type select changes
            onBtnTypeChange: Callback when btn type select changes
            onBtnNumChange: Callback when btn num input changes
            onDownBtnClick: When the down btn is clicked, it will generate the btnController children. 
                Developer can also add extra function by defining this api. It will be called after the generating function.
                Takes one argument: target
                    {
                        index: getSelfIndex(),
                        groupType: groupType,
                        btnType: btnType,
                        btnNum: btnNum
                    };
            onDelete: Callback when delete btn clicked. Takes one argument: target {index: int}
            // skeletonData: to pass to child SkeletonEdgeController to hold generated edge data if user choose 'skeleton'
            // setSkeletonData: skeletonData setter. To pass to child SkeletonEdgeController
    */
        
    
    const [index, setIndex] = useState();
    const [groupType, setGroupType] = useState();
    const [btnType, setBtnType] = useState();
    const [btnNum, setBtnNum] = useState(0);
    const [error, setError] = useState();
    const [children, setChildren] = useState([]);
    // const [childrenData, setChildrenData] = useState([]);
    const prevBtnNumRef = useRef(0);
    const prevBtnTypeRef = useRef();
    const [addEdge, setAddEdge] = useState(false);
    const [disableEdgeBtn, setDisableEdgeBtn] = useState(true);

    console.log('btnGroupController render');

    const btnGroupOptions = [
        {value: 'shape', label: 'Shape'},
        {value: 'category', label: 'Category'},
        {value: 'skeleton', label: 'Skeleton'},
    ]

    const btnOptions = {
        category: [
            {value: 'category', label: 'Category'}
        ],
        shape: [
            {value: 'keyPoint', label: 'Key Point'},
            {value: 'bbox', label: 'Bounding Box'},
            {value: 'polygon', label: 'Polygon'},
        ],
        skeleton: [
            {value: 'skeleton', label: 'Skeleton'}
        ],
        general: [
            {value: 'category', label: 'Category'},
            {value: 'keyPoint', label: 'Key Point'},
            {value: 'bbox', label: 'Bounding Box'},
            {value: 'polygon', label: 'Polygon'},
            {value: 'skeleton', label: 'Skeleton'},
        ]
    }


    useEffect(()=>{
        if (!props.data || !props.setData) {
            throw Error('Property data and setData are required, cannot be null or undefined');
        }
        if (!props.index) {
            setIndex(Date.now().toString());
        }
      },[]
    )


    useEffect(() => {
        // to update callback's scope when data changes
        // rerender addEdge btn when disableEdgeBtn state changes
        // console.log('useEffect called');
        if (props.data && getSelfIndex()) { // avoid calling when component just mounted
            renderChildren(); //update callback's scope
        } 

      }, [props.data, disableEdgeBtn]
    )

    useEffect(() => {
        // when child label change, check if all children have label, if yes, enable add edge
        if (props.data && getSelfIndex() && props.data[getSelfIndex()].groupType === 'skeleton') {
            checkLabels(); 
        }
    }, [props.data])


    function onGroupTypeChange(newValue, opt) {
        // console.log(newValue);
        // console.log(btnOptions[newValue]);
        setGroupType(newValue);
        setBtnType(btnOptions[newValue][0]['value']);

        // if user has defined custom callback
        if (props.onGroupTypeChange) {
            const target = {
                index: getSelfIndex(),
                value: newValue,
                label: opt.label
            };
            props.onGroupTypeChange(target);
        }
    }

    function onBtnTypeChange(newValue, opt) {
        setBtnType(newValue);

        // if user has defined custom callback
        if (props.onBtnTypeChange) {
            const target = {
                index: getSelfIndex(),
                value: newValue,
                label: opt.label
            };
            props.onBtnTypeChange(target);
        }
    }

    function onBtnNumChange(newValue) {
        const max = props.maxBtnNum ? props.maxBtnNum : BTNNUM_MAX;
        if (typeof newValue === 'number' 
        && Number.isInteger(newValue) 
        && newValue>=0 
        && newValue<=max) {
            setBtnNum(newValue);
            setError(null);
            // if user has defined custom callback
            if (props.onBtnNumChange) {
                const target = {
                    index: getSelfIndex(),
                    value: newValue,
                };
                props.onBtnNumChange(target);
            }
        } else {
            setBtnNum(prevBtnNumRef.current);
            setError(`Btn num should be integer no more than ${max}`);
        }
    }

    function onDownBtnClick() {
        const index = getSelfIndex();
        const childrenData = getData();
        let data = [];
        if (groupType && btnType) {
            if (btnType !== prevBtnTypeRef.current) {
                console.log(btnType, prevBtnTypeRef.current);
                data = createChildrenData(0, btnNum);
            } else {
                if (btnNum > prevBtnNumRef.current) {
                    // console.log('>');
                    const newData = createChildrenData(prevBtnNumRef.current, btnNum);
                    data = [...childrenData, ...newData];
                } else if (btnNum < prevBtnNumRef.current) {
                    // console.log('<');
                    data = [...childrenData].slice(0, btnNum);
                } else {
                    // console.log('=');
                    data = childrenData;
                }
            }
            // props.setData({...props.data, [index]: data});
            // prevBtnNumRef.current = btnNum;
            // prevBtnTypeRef.current = btnType;
        } 
        // else {
            // props.setData({...props.data, [index]: []});
        // }
        prevBtnNumRef.current = btnNum;
        prevBtnTypeRef.current = btnType;

        props.setData({...props.data, [index]: {
            // groupIndex: getSelfIndex(),
            groupType: groupType,
            btnType: btnType,
            btnNum: btnNum,
            childData: data
        }});

        if (props.onDownBtnClick) {
            const target = {
                index: getSelfIndex(),
                groupType: groupType,
                btnType: btnType,
                btnNum: btnNum
            };
            props.onDownBtnClick(target);
        }        
    }

    function getData() {
        const index = getSelfIndex();
        let data = props.data[index].childData;
        if (!data) {
            data=[]
        }
        return data; //arr
    }

    function getSelfIndex() {
        return props.index ? props.index : index; 
    }

    function createChildrenData(startIndex, endIndex) {
        const newData=[];
        for (let i = startIndex; i < endIndex; i++) {
            const data = {
                index: i,
                // groupType: groupType,
                btnType: btnType,
                label: '',
                color: '#1677FF',

            };
            newData.push(data);
        }
        return newData;
    }


    function renderChildren() {
        console.log('renderChildren called');
        const childrenData = getData();
        // console.log(childrenData);
        let res = [];
        for (let i = 0; i < childrenData.length; i++) {
            res.push(
                <BtnController 
                    key={i}
                    index={i} 
                    // data={childrenData[i]}
                    // groupType={childrenData[i].groupType}
                    btnType={childrenData[i].btnType}
                    color={childrenData[i].color}
                    label={childrenData[i].label}
                    typeSelectPlaceHolder='Btn type'
                    labelPlaceHolder="Label: e.g. 'mouse'"
                    disableTypeSelect
                    enableDelete
                    // onTypeChange={onChildTypeChange}
                    onLabelChange={onChildLabelChange}
                    onColorChange={onChildColorChange}
                    onDelete={onChildDelete}
                    />); 
        }
        // console.log(childrenData[0], childrenData[0].btnType === 'skeleton');
        if (childrenData[0] && childrenData[0].btnType === 'skeleton') {
            // console.log(childrenData[0].btnType=== 'skeleton');
            res.push(
                <Button key={childrenData.length} onClick={onAddEdgeBtnClick} disabled={disableEdgeBtn}>Add Edge</Button>
            
            // <SkeletonEdgeController 
            //             index={getSelfIndex()}
            //             vertices={generateSkeletonVerticesData()}
            //             data={props.skeletonData}
            //             setData={props.setSkeletonData} 
            //              />
                    );
        }
        console.log(res);
        setChildren(res);
    }


    function onDelete() {
        const target = {
            index: getSelfIndex(),
        }

        if (props.onDelete) {
            props.onDelete(target);
        }
    }

    
    function onChildLabelChange(target) {
        // console.log('parent ',target);
        const index = getSelfIndex();
        const childrenData = getData();
        const data = {...childrenData[target.index]}; //btn data
        // console.log('label', children[target.index]);
        data.label = target.value;
        // console.log(data);
        const childrenDataCopy = [...childrenData];
        childrenDataCopy[target.index] = data;
        props.setData({...props.data, [index]: {
            // groupIndex: getSelfIndex(),
            groupType: groupType,
            btnType: btnType,
            btnNum: btnNum,
            childData: childrenDataCopy
        } });
    } 

    function onChildColorChange(target) {
        const index = getSelfIndex();
        const childrenData = getData();
        const data = {...childrenData[target.index]};
        // console.log('color', childrenData);
        data.color = target.value;
        // console.log(data);
        const childrenDataCopy = [...childrenData];
        childrenDataCopy[target.index] = data;
        // props.setData({...props.data, [index]: childrenDataCopy});
        props.setData({...props.data, [index]: {
            // groupIndex: getSelfIndex(),
            groupType: groupType,
            btnType: btnType,
            btnNum: btnNum,
            childData: childrenDataCopy
        } });
    }

    function onChildDelete(target) {
        setBtnNum(btnNum-1);
        prevBtnNumRef.current = prevBtnNumRef.current>0 ? prevBtnNumRef.current-1 : 0;
        const index = getSelfIndex();
        const newChildrenData = [...getData().filter(item=>item.index!==target.index)];
        // newChildrenData.splice(target.index, 1);
        newChildrenData.forEach((item,i) => {item.index=i});
        // props.setData({...props.data, [index]: newChildrenData});
        props.setData({...props.data, [index]: {
            // groupIndex: getSelfIndex(),
            groupType: groupType,
            btnType: btnType,
            btnNum: btnNum,
            childData: newChildrenData
        } });
    }

    function onAddEdgeBtnClick() {
        setAddEdge(true);
    }

    function checkLabels() {
        const childData = getData();
        // console.log(childData);
        let childWithLabel = 0;
        // if (childData) {
            for (const child of childData) {
                // console.log(child, child.label, typeof child.label === 'string', child.label!=='');
                if (typeof child.label === 'string' && child.label!=='') {
                    childWithLabel++;
                }
            }
        // }
        // console.log(childWithLabel, childWithLabel==childData.length);
        if (childWithLabel==childData.length) {
            setDisableEdgeBtn(false);
        } else {
            setDisableEdgeBtn(true);
            setAddEdge(false);
        }
    }

    function generateSkeletonVerticesData() {
        // console.log(getData());
        return getData().map(item => item.label);
    }


    return (
        <div className='my-1'>
            <div className='my-2 d-inline-flex'>
                <Space.Compact block className='px-0'>
                    <Select className={styles.groupSelect}
                        // defaultValue={btnGroupOptions[0].value}
                        defaultValue={props.defaultGroupType}
                        value={groupType}
                        onChange={onGroupTypeChange}
                        options={btnGroupOptions}
                        placeholder={props.groupTypePlaceHolder}
                        disabled={props.disableGroupTypeSelect}
                        />
                    <Select className={styles.btnSelect}
                        defaultValue={props.defaultBtnType}
                        value={btnType}
                        onChange={onBtnTypeChange}
                        options={groupType ? btnOptions[groupType] : btnOptions.general}
                        // placeholder={props.btnTypePlaceHolder}
                        disabled={props.disableBtnTypeSelect}
                        />
                    <InputNumber className={styles.numInput}
                        // className={videoStyles.playFpsInput} 
                        // min={0}
                        // max={props.maxBtnNum ? props.maxBtnNum : BTNNUM_MAX}
                        defaultValue={props.defualtBtnNum}
                        value={btnNum}
                        onChange={onBtnNumChange}
                        // size="small"
                        disabled={props.disableBtnNumInput}
                        />
                </Space.Compact>

                {/* {props.enableDelete ? */}
                    <Button className={styles.generateBtn} 
                        // shape='circle'
                        type='text'
                        icon={<DownOutlined />}
                        onClick={onDownBtnClick} 
                        // size='small'
                        />
                    {/* :null
                } */}
                {props.enableDelete ?
                    <Button className={styles.deleteBtn} 
                        // shape='circle'
                        type='text'
                        icon={<DeleteOutlined />} 
                        onClick={onDelete}
                        // size='small'
                        />
                    :null
                }
            </div>
            {error ?
                <p className='ms-3'>{error}</p>
                : null
            }
            <div className='ms-3'>
                {children ?
                    <Space direction='vertical'>
                        {children}
                    </Space>
                    : null
                }
                {addEdge ?
                    <div className='my-3 mx-2'> 
                    <SkeletonEdgeController 
                        index={getSelfIndex()}
                        vertices={generateSkeletonVerticesData()}
                        data={props.data}
                        setData={props.setData}
                        setAddEdge={setAddEdge}
                        />
                    </div>
                    :null   
                }
            </div>
        </div>
    )
}